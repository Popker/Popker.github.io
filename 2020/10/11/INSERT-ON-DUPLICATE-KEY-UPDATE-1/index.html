<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    <link rel="shortcut icon" type='image/x-icon' href="/web.png">


    <!-- meta -->


<title>INSERT ... ON DUPLICATE KEY UPDATE(1) - 原罪 | Popker-Tech|Life</title>


    <meta name="keywords" content="数据库">




    <!-- OpenGraph -->


    
<link rel="stylesheet" href="/css/style/main.css">
 



    
    
        <link rel="stylesheet" id="hl-default-theme" href="/css/highlight/default.css" media="none" onload="if(getComputedStyle(document.documentElement).getPropertyValue('--color-mode').indexOf('dark')===-1)this.media='all'">
        
    

    
    

     

    <!-- custom head -->

<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Popker-Tech|Life" type="application/atom+xml">
</head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">
                Popker
            </span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">
                        首页
                    </a>
                
                    <a href="/shuoshuo/" class="navbar-menu button">
                        批话收集器
                    </a>
                
                    <a href="/tags/" class="navbar-menu button">
                        标签
                    </a>
                
                    <a href="/archives/" class="navbar-menu button">
                        归档
                    </a>
                
                    <a href="/github/" class="navbar-menu button">
                        GitHub
                    </a>
                
            </div>
        
        
        
    <a href="/search/" id="btn-search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="24" height="24" fill="currentColor" stroke="currentColor" stroke-width="32"><path d="M192 448c0-141.152 114.848-256 256-256s256 114.848 256 256-114.848 256-256 256-256-114.848-256-256z m710.624 409.376l-206.88-206.88A318.784 318.784 0 0 0 768 448c0-176.736-143.264-320-320-320S128 271.264 128 448s143.264 320 320 320a318.784 318.784 0 0 0 202.496-72.256l206.88 206.88 45.248-45.248z"></path></svg>
    </a>


        
        

         
    <a href="#" class="button" id="b2t" aria-label="Back to Top" title="Back to Top">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M233.376 722.752L278.624 768 512 534.624 745.376 768l45.248-45.248L512 444.128zM192 352h640V288H192z" fill="currentColor"></path>
        </svg>
    </a>


        
            <a class="dropdown-icon button" id="btn-dropdown">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round">
                    <path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path>
                </svg>
            </a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/" class="dropdown-menu button">
                        首页
                    </a>
                
                    <a href="/shuoshuo/" class="dropdown-menu button">
                        批话收集器
                    </a>
                
                    <a href="/tags/" class="dropdown-menu button">
                        标签
                    </a>
                
                    <a href="/archives/" class="dropdown-menu button">
                        归档
                    </a>
                
                    <a href="/github/" class="dropdown-menu button">
                        GitHub
                    </a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        INSERT ... ON DUPLICATE KEY UPDATE(1) - 原罪
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2020/10/" class="post-meta__date button">
    2020-10-11
</a>
        
 
        
    
    


 

 
    </div>
</div>



<article class="post content-card">
    <div class="post__header">
    
        <div class="post-thumbnail" style="background-image: url('https://s1.ax1x.com/2020/10/15/0IzOwq.jpg');"></div>
    
</div>
    <div class="post__content">
        <blockquote>
<p>INSERT…ON DUPLICATE KEY UPDATE is a problematic construct. - Marko Mäkelä</p>
</blockquote>
<h3 id="0-概述：MySQL-5-7-x以后，INSERT…ON-DUPLICATE-KEY-UPDATE出现过哪些问题？"><a href="#0-概述：MySQL-5-7-x以后，INSERT…ON-DUPLICATE-KEY-UPDATE出现过哪些问题？" class="headerlink" title="0 概述：MySQL 5.7.x以后，INSERT…ON DUPLICATE KEY UPDATE出现过哪些问题？"></a>0 概述：MySQL 5.7.x以后，INSERT…ON DUPLICATE KEY UPDATE出现过哪些问题？</h3><table>
<thead>
<tr>
<th>bug编号</th>
<th>影响版本及修复</th>
<th>描述</th>
<th>link</th>
</tr>
</thead>
<tbody><tr>
<td>58637</td>
<td>till now</td>
<td>INSERT…ON DUPLICATE KEY UPDATE语句在有多个unique key的情况下，存储引擎检查key的顺序对语句执行影响很大，因此导致诸如SBR主从不同步的问题</td>
<td><a target="_blank" rel="noopener" href="https://bugs.mysql.com/bug.php?id=58637">https://bugs.mysql.com/bug.php?id=58637</a></td>
</tr>
<tr>
<td>50413/25966845</td>
<td>5.7.27之前所有版本</td>
<td>INSERT ON DUPLICATE KEY UPDATE 语句存在事务隔离级别的问题，导致事务隔离性[1]出现了问题（the interleaved transactions execute in a non-serializable order）</td>
<td><a target="_blank" rel="noopener" href="https://bugs.mysql.com/bug.php?id=50413">https://bugs.mysql.com/bug.php?id=50413</a></td>
</tr>
</tbody></table>
<p>可以看到，即使迭代了这么多版本后。INSERT…ON DUPLICATE KEY UPDATE依然有着这样那样的问题。本文后面来分析上述Bug产生原因以及MySQL官方的修复方案，借此窥探一下INSERT…ON DUPLICATE KEY UPDATE到底为何有这么多问题。</p>
<h3 id="1-Bug-58637分析"><a href="#1-Bug-58637分析" class="headerlink" title="1 Bug#58637分析"></a>1 Bug#58637分析</h3><h4 id="1-1-问题原因"><a href="#1-1-问题原因" class="headerlink" title="1.1 问题原因"></a>1.1 问题原因</h4><p>Bug链接中有MySQL开发者<strong>Sven Sandberg</strong>对这个问题的详细描述，主要意思是:</p>
<p>当MySQL执行INSERT…ON DUPLICATE KEY UPDATE语句时，存储引擎会检查insert的行是否有duplicate key冲突；但当表里有两个及以上的唯一键（包括primary key和uniq key）时，INSERT…ON DUPLICATE KEY UPDATE执行检查duplicate key冲突时，会<strong>依赖于存储引擎检查key的顺序</strong>，存储引擎检查不同的顺序导致更新不同的行（依赖存储引擎的实现）。</p>
<p>举个例子，Innodb是<strong>根据索引建立的顺序</strong>来检查，先建立的索引会优先检查，那么就导致了如果主从添加索引的顺序不一致，就会使<strong>主从数据不一致</strong>（基于SBR复制）。而主从建立索引的顺序不一致也是在现实中极有可能发生的，比如还没有从库时，主库先建了表，然后通过ALTER TABLE/CREATE INDEX添加索引，从库启动时使用mysqldump来同步,这样从库只会执行一次CREATE TABLE语句来建立表和索引，可能使得索引顺序与主库不同。</p>
<p>（但REPLACE却没有这个问题，因为REPLACE是去除<strong>所有duplicate key</strong>，再执行操作）</p>
<h4 id="1-2-复现例子"><a href="#1-2-复现例子" class="headerlink" title="1.2 复现例子"></a>1.2 复现例子</h4><table>
<thead>
<tr>
<th>主库</th>
<th>从库</th>
</tr>
</thead>
<tbody><tr>
<td>CREATE TABLE t1 (a INT, b INT UNIQUE KEY) ENGINE = InnoDB; <br />ALTER TABLE t1 ADD UNIQUE KEY(a);</td>
<td></td>
</tr>
<tr>
<td></td>
<td>（表定义一样，只是在一个语句里执行）<br />DROP TABLE t1;<br />CREATE TABLE t1 (a INT UNIQUE KEY, b INT UNIQUE KEY) ENGINE = InnoDB;</td>
</tr>
<tr>
<td>INSERT INTO t1 VALUES (1, 1);<br /> INSERT INTO t1 VALUES (2, 2); <br />INSERT INTO t1 VALUES (1, 2)   ON DUPLICATE KEY UPDATE a=VALUES(a)+10, b=VALUES(b)+10;</td>
<td></td>
</tr>
<tr>
<td>SELECT * FROM t1;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>SELECT * FROM t1;</td>
</tr>
</tbody></table>
<p>最终主库得到的是(1,1) (12,12)，从库得到的是(11,11) (2,2)。主从数据失去同步。</p>
<h4 id="1-3-MySQL的解决方法及分析"><a href="#1-3-MySQL的解决方法及分析" class="headerlink" title="1.3 MySQL的解决方法及分析"></a>1.3 MySQL的解决方法及分析</h4><p>由于该问题是INSERT…ON DUPLICATE KEY UPDATE自身的问题，并没有好的解决方式。所以MySQL官方在5.5.24版本和5.6版本时，将存在多个唯一键的表的INSERT ON DUPLICATE KEY UPDATE语句标记为在SBR下Unsafe。</p>
<p>在MYSQL5.7的官方文档中<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/replication-rbr-safe-unsafe.html">[2]Determination of Safe and Unsafe Statements in Binary Logging</a>，我们可以看到描述:</p>
<blockquote>
<p><strong>INSERT … ON DUPLICATE KEY UPDATE statements on tables with multiple primary or unique keys.</strong> When executed against a table that contains more than one primary or unique key, this statement is considered unsafe, being sensitive to the order in which the storage engine checks the keys, which is not deterministic, and on which the choice of rows updated by the MySQL Server depends.</p>
<p>An <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/insert-on-duplicate.html"><code>INSERT ... ON DUPLICATE KEY UPDATE</code></a> statement against a table having more than one unique or primary key is marked as unsafe for statement-based replication. (Bug #11765650, Bug #58637)</p>
</blockquote>
<h3 id="2-Bug-50413-25966845分析"><a href="#2-Bug-50413-25966845分析" class="headerlink" title="2 Bug#50413/25966845分析"></a>2 Bug#50413/25966845分析</h3><h4 id="2-1-问题原因"><a href="#2-1-问题原因" class="headerlink" title="2.1 问题原因"></a>2.1 问题原因</h4><p>在5.7.27之前（不包括5.27），INSERT…ON DUPLICATE KEY UPDATE语句在多个唯一键，在没有检查到DUPLICATE KEY的时候，没有对没找到的key加锁，使得其他事务可以影响当前事务的最终结果，最终导致事务隔离性出现了问题，从而影响了MySQL的复制。2.2中会给出典型的例子。</p>
<h4 id="2-2-复现例子"><a href="#2-2-复现例子" class="headerlink" title="2.2 复现例子"></a>2.2 复现例子</h4><p>原始表格</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(</span><br><span class="line">  f1 <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">  f2 <span class="built_in">int</span> <span class="keyword">unique</span> <span class="keyword">key</span>,</span><br><span class="line">  f3 <span class="built_in">int</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1(f1,f2,f3) <span class="keyword">values</span> (<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>两次实验会执行相同SQL，并且<strong>总是让TRX2先于TRX1提交</strong>。</p>
<h5 id="2-2-1-MySQL-Community-Server-5-7-18"><a href="#2-2-1-MySQL-Community-Server-5-7-18" class="headerlink" title="2.2.1 MySQL Community Server 5.7.18"></a>2.2.1 <strong>MySQL Community Server 5.7.18</strong></h5><p>TRX1先执行:</p>
<table>
<thead>
<tr>
<th>TRX1</th>
<th>TRX2</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td>begin;</td>
</tr>
<tr>
<td>insert into t1 values(2, 10, 200) on duplicate key update f3 = 120;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t1 values(2, 20, 300) on duplicate key update f3 = 500;</td>
</tr>
<tr>
<td></td>
<td>commit;</td>
</tr>
<tr>
<td>commit;</td>
<td></td>
</tr>
</tbody></table>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+------+------+</span><br><span class="line">| f1 | f2   | f3   |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  1 |   10 |  120 |</span><br><span class="line">|  2 |   20 |  300 |</span><br><span class="line">+----+------+------+</span><br></pre></td></tr></table></figure>



<p>TRX2先执行：</p>
<table>
<thead>
<tr>
<th>RX1</th>
<th>TRX2</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td>begin;</td>
</tr>
<tr>
<td></td>
<td>insert into t1 values(2, 20, 300) on duplicate key update f3 = 500;</td>
</tr>
<tr>
<td>insert into t1 values(2, 10, 200) on duplicate key update f3 = 120;</td>
<td></td>
</tr>
<tr>
<td>阻塞</td>
<td></td>
</tr>
<tr>
<td></td>
<td>commit;</td>
</tr>
<tr>
<td>commit;</td>
<td></td>
</tr>
</tbody></table>
<p>结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+------+------+</span><br><span class="line">| f1 | f2   | f3   |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  1 |   10 |  100 |</span><br><span class="line">|  2 |   20 |  120 |</span><br><span class="line">+----+------+------+</span><br></pre></td></tr></table></figure>



<h5 id="2-2-2-MySQL-Community-Server-5-7-31"><a href="#2-2-2-MySQL-Community-Server-5-7-31" class="headerlink" title="2.2.2 MySQL Community Server 5.7.31"></a>2.2.2 MySQL Community Server 5.7.31</h5><p>TRX1先执行:</p>
<table>
<thead>
<tr>
<th>TRX1</th>
<th>TRX2</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td>begin;</td>
</tr>
<tr>
<td>insert into t1 values(2, 10, 200) on duplicate key update f3 = 120;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t1 values(2, 20, 300) on duplicate key update f3 = 500;</td>
</tr>
<tr>
<td></td>
<td>阻塞</td>
</tr>
</tbody></table>
<p>结果：</p>
<p>没有结果，TRX2执行完语句后就阻塞住了，不能先于TRX1提交。</p>
<p>TRX2先执行：</p>
<table>
<thead>
<tr>
<th>RX1</th>
<th>TRX2</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td>begin;</td>
</tr>
<tr>
<td></td>
<td>insert into t1 values(2, 20, 300) on duplicate key update f3 = 500;</td>
</tr>
<tr>
<td>insert into t1 values(2, 10, 200) on duplicate key update f3 = 120;</td>
<td></td>
</tr>
<tr>
<td>阻塞</td>
<td></td>
</tr>
<tr>
<td></td>
<td>commit;</td>
</tr>
<tr>
<td>commit;</td>
<td></td>
</tr>
</tbody></table>
<p>结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+------+------+</span><br><span class="line">| f1 | f2   | f3   |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  1 |   10 |  100 |</span><br><span class="line">|  2 |   20 |  120 |</span><br><span class="line">+----+------+------+</span><br></pre></td></tr></table></figure>



<h4 id="2-3-MySQL的解决方法及分析"><a href="#2-3-MySQL的解决方法及分析" class="headerlink" title="2.3 MySQL的解决方法及分析"></a>2.3 MySQL的解决方法及分析</h4><p>可以看到，在Bug修复前，相同的事务提交顺序（都是TRX2优先于TRX1提交），最终结果却受到了并发事务内部执行的先后顺序的影响。</p>
<p>为什么INSERT…ON DUPLICATE KEY UPDATE会有这个问题，对于MySQL开发人员来说，困难点在于当这里有多个uniq key约束时，哪个约束被违反就变的很重要了。因为这会影响哪一行被更新。（注意和上一个问题的区别，上一个问题主要<strong>一个语句</strong>检查到两个uniq key同时违反时候的顺序问题，这个问题更强调只违反了一个key，但可能带给<strong>并发事务</strong>的影响）</p>
<p>为了隔离性，MySQL需要”lock everything we saw to make decision”（锁住看到的一切来做出决定）。</p>
<p>5.7.26以后，只对发生冲突和没发生冲突的行，都会加行锁（上例中的f1=2的场景），不会添加其他锁；</p>
<p>而在Bug修复前（5.7.4之后），</p>
<p>有冲突时：</p>
<p>INSERT…ON DUPLICATE KEY UPDATE会对有冲突的行加next-key lock(which just on the index record and a gap lock on the gap before the index record)，而不会对没有冲突的行加锁（发生原因）。</p>
<blockquote>
<p>有趣的是，这个时期5.7.4-5.7.25之前，即使隔离级别是RC，依然会对有冲突的行加next-key lock。和一般认知下RC没有gap锁是冲突的。</p>
</blockquote>
<p>而完全没有冲突时：</p>
<p>INSERT…ON DUPLICATE KEY UPDATE会对插入行的上下gap都加锁（并发下导致死锁，见下一节）。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observe that on the leader the con1 made a decision that the conflict is on f2 (as opposed to f1) by first observing that there is no row with f1&#x3D;2.</span><br><span class="line">How did it observe it? By temporarily creating a record in primary index with f1&#x3D;2 and seeing that it succeeded.</span><br><span class="line">Only later, when it found a conflict on f2 and decided to remove the record.</span><br><span class="line">By removing the record, con1 removed a part of &quot;proof&quot; that it saw no conflict on f1.</span><br><span class="line">This is why con2 was able to insert a row with f1&#x3D;2, which later lead to replication issues.</span><br><span class="line">The correct way to &quot;preserve the evidence&quot; would be to make sure that the gap in which f1&#x3D;2 was remains locked until con1 commits.</span><br><span class="line">This can be accomplished by creating explicit lock on the temporary row, and then let it be inherited on removal.</span><br><span class="line">Such explicit lock can be created by so called implicit-to-explicit conversion.</span><br><span class="line">The con1 already had an implicit lock on the record, because its TRX_ID was in the row&#39;s header as the id of the trx which written it.</span><br><span class="line">But this implicit lock will vanish as soon as we remove the record physically, so it needs to be saved as an explicit lock in memory.</span><br><span class="line">the old code(Bug#50413 Fix) forgot to convert implicit lock on the temporarly inserted row to explicit lock, </span><br><span class="line">and thus it was not inherited and thus there is no gap protecting the proof that there was no conflict on primary key.</span><br><span class="line">**This change(Bug#25966845 Fix) follows from realisation, that in case we have to remove the row we will properly inherit the lock as a gap lock, and if we don&#39;t remove it, then there is no need to protect the gap.**</span><br><span class="line">So, this should increase parallelism. </span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2-4-一件有意思的事"><a href="#2-4-一件有意思的事" class="headerlink" title="2.4 一件有意思的事"></a>2.4 一件有意思的事</h4><p>有趣的是，在BUG 50413时，MySQL开发人员已经发现INSERT…ON DUPLICATE KEY UPDATE语句存在隔离性问题。在5.7.4中还修复了一版本，在遇到duplicate key时，给<strong>被检测到duplicate key的行</strong>加Next Key Lock。但这明显对隔离性这个问题没有起到作用，所以才在Bug #25966845 5.7.26修复成了2.3中分析的样子。</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h3><p>INSERT…ON DUPLICATE KEY UPDATE有如此多的问题，我们应该在实际开发中避免使用吗？我想不是的，一些业务场景避免不了使用它，但使用时必须明白这些BUG对数据库带来的影响，避免导致一些问题，如死锁。INSERT…ON DUPLICATE KEY UPDATE死锁问题是我在实际开发中遇到的，也会在INSERT…ON DUPLICATE KEY UPDATE下一篇文章当中进行分析。</p>
<hr>
<h4 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h4><p>[1] 事务隔离性 : 即ACID中的I(Isolation)，对于并发执行的多个事务进行合理的排序，保障了不同事务的执行互不干扰。换言之，隔离性这种特性，能够让并发执行的多个事务就好像是按照「先后顺序」执行的一样。</p>
<p>[2] The “safeness” of a statement in MySQL Replication, refers to whether the statement and its effects can be replicated correctly using statement-based format.（安全在Mysql复制里，指的是在SBR下，语句能否复制正确）</p>

    </div>
     
    <div class="post-footer__meta">
    <p>
        updated at 2020-10-26
    </p>
</div> 
    <div class="post-meta__cats">
    
    
        <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-tags__link button"># 数据库</a>
    
</div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/2020/10/25/INSERT%20...%20ON%20DUPLICATE%20KEY%20UPDATE(1)%20-%20%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            Previous Post
                        </div>
                        <div class="nav__title">
                            INSERT ... ON DUPLICATE KEY UPDATE(1) - 死锁问题
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
                <a href="/2018/09/06/Linux%E4%B8%8B%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            Next Post
                        </div>
                        <div class="nav__title">
                            Linux下线程、进程和协程
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
    


    
     
 

 
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
         

 

 

 

  



 


    
 

 

 

 




    </body>
</html>
